
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>database: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/not-empty/grit/app/database/database.go (100.0%)</option>
				
				<option value="file1">github.com/not-empty/grit/app/helper/chain_helper.go (100.0%)</option>
				
				<option value="file2">github.com/not-empty/grit/app/helper/data_helper.go (100.0%)</option>
				
				<option value="file3">github.com/not-empty/grit/app/helper/error_helper.go (100.0%)</option>
				
				<option value="file4">github.com/not-empty/grit/app/helper/fields_helper.go (100.0%)</option>
				
				<option value="file5">github.com/not-empty/grit/app/helper/filters_helper.go (100.0%)</option>
				
				<option value="file6">github.com/not-empty/grit/app/helper/order_helper.go (100.0%)</option>
				
				<option value="file7">github.com/not-empty/grit/app/helper/pagination_helper.go (100.0%)</option>
				
				<option value="file8">github.com/not-empty/grit/app/helper/routes_helper.go (100.0%)</option>
				
				<option value="file9">github.com/not-empty/grit/app/helper/scan_helper.go (100.0%)</option>
				
				<option value="file10">github.com/not-empty/grit/app/helper/validator_helper.go (100.0%)</option>
				
				<option value="file11">github.com/not-empty/grit/app/middleware/auth_middleware.go (100.0%)</option>
				
				<option value="file12">github.com/not-empty/grit/app/middleware/chains_middleware.go (100.0%)</option>
				
				<option value="file13">github.com/not-empty/grit/app/middleware/cors_middleware.go (100.0%)</option>
				
				<option value="file14">github.com/not-empty/grit/app/middleware/id_middleware.go (100.0%)</option>
				
				<option value="file15">github.com/not-empty/grit/app/middleware/jwt_middleware.go (100.0%)</option>
				
				<option value="file16">github.com/not-empty/grit/app/middleware/log_middleware.go (100.0%)</option>
				
				<option value="file17">github.com/not-empty/grit/app/middleware/recover_middleware.go (100.0%)</option>
				
				<option value="file18">github.com/not-empty/grit/app/middleware/response_middleware.go (100.0%)</option>
				
				<option value="file19">github.com/not-empty/grit/app/middleware/sanitize_middleware.go (100.0%)</option>
				
				<option value="file20">github.com/not-empty/grit/app/util/jwt_manager/jwt_manager.go (1.9%)</option>
				
				<option value="file21">github.com/not-empty/grit/app/util/ulid/ulid.go (39.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "os"
        "strconv"

        _ "github.com/go-sql-driver/mysql"
)

// Config holds the database connection configuration.
type Config struct {
        User    string
        Pass    string
        Host    string
        Port    string
        Name    string
        MaxOpen int
        MaxIdle int
}

// SqlOpenFunc defines a function signature to open SQL connections (mockable).
var SqlOpenFunc = sql.Open

// DbPingFunc defines how to ping the DB (mockable in tests).
var DbPingFunc = func(db *sql.DB) error <span class="cov8" title="1">{
        return db.Ping()
}</span>

// LoadConfigFromEnv loads DB config from environment variables.
func LoadConfigFromEnv() Config <span class="cov8" title="1">{
        maxconn, err1 := strconv.Atoi(os.Getenv("DB_MAX_CONN"))
        maxidle, err2 := strconv.Atoi(os.Getenv("DB_MAX_IDLE"))

        if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Invalid DB_MAX_CONN or DB_MAX_IDLE: %v %v", err1, err2))</span>
        }

        <span class="cov8" title="1">return Config{
                User:    os.Getenv("DB_USER"),
                Pass:    os.Getenv("DB_PASS"),
                Host:    os.Getenv("DB_HOST"),
                Port:    os.Getenv("DB_PORT"),
                Name:    os.Getenv("DB_NAME"),
                MaxOpen: maxconn,
                MaxIdle: maxidle,
        }</span>
}

// Init establishes a new *sql.DB connection from the given config.
func Init(cfg Config) *sql.DB <span class="cov8" title="1">{
        if cfg.User == "" || cfg.Pass == "" || cfg.Host == "" || cfg.Port == "" || cfg.Name == "" || cfg.MaxOpen &lt;= 0 || cfg.MaxIdle &lt; 0 </span><span class="cov8" title="1">{
                panic("Missing or invalid database configuration")</span>
        }

        <span class="cov8" title="1">dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?parseTime=true", cfg.User, cfg.Pass, cfg.Host, cfg.Port, cfg.Name)
        db, err := SqlOpenFunc("mysql", dsn)
        if err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Error opening database: %v", err))</span>
        }

        <span class="cov8" title="1">db.SetMaxOpenConns(cfg.MaxOpen)
        db.SetMaxIdleConns(cfg.MaxIdle)

        if err := DbPingFunc(db); err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Error connecting to database: %v", err))</span>
        }

        <span class="cov8" title="1">return db</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helper

import "net/http"

func Chain(handler http.Handler, middlewares ...func(http.Handler) http.Handler) http.Handler <span class="cov8" title="1">{
        for i := len(middlewares) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                handler = middlewares[i](handler)
        }</span>
        <span class="cov8" title="1">return handler</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package helper

import (
        "encoding/json"
)

func FilterJSON(model interface{}, fields []string) map[string]interface{} <span class="cov8" title="1">{
        data, _ := json.Marshal(model)
        var all map[string]interface{}
        _ = json.Unmarshal(data, &amp;all)

        if fields == nil || len(fields) == 0 </span><span class="cov8" title="1">{
                return all
        }</span>

        <span class="cov8" title="1">filtered := make(map[string]interface{})
        for _, f := range fields </span><span class="cov8" title="1">{
                if val, ok := all[f]; ok </span><span class="cov8" title="1">{
                        filtered[f] = val
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package helper

import (
        "encoding/json"
        "net/http"
)

type ErrorResponse struct {
        Error string `json:"error"`
}

// Accepts either error or string as the last param
func JSONError(w http.ResponseWriter, status int, msg interface{}) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        var message string

        switch v := msg.(type) </span>{
        case error:<span class="cov8" title="1">
                message = v.Error()</span>
        case string:<span class="cov8" title="1">
                message = v</span>
        default:<span class="cov8" title="1">
                message = "Unknown error"</span>
        }

        <span class="cov8" title="1">json.NewEncoder(w).Encode(ErrorResponse{Error: message})</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package helper

import (
        "net/http"
        "strings"
)

func GetFieldsParam(r *http.Request, allowedFields []string) []string <span class="cov8" title="1">{
        query := r.URL.Query().Get("fields")
        if query == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">requested := strings.Split(query, ",")
        allowedMap := make(map[string]struct{}, len(allowedFields))
        for _, f := range allowedFields </span><span class="cov8" title="1">{
                allowedMap[f] = struct{}{}
        }</span>

        <span class="cov8" title="1">var valid []string
        for _, field := range requested </span><span class="cov8" title="1">{
                field = strings.TrimSpace(field)
                if _, ok := allowedMap[field]; ok </span><span class="cov8" title="1">{
                        valid = append(valid, field)
                }</span>
        }

        <span class="cov8" title="1">if len(valid) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return valid</span>
}

func FilterFields(requested, allowed []string) []string <span class="cov8" title="1">{
        if len(requested) == 0 </span><span class="cov8" title="1">{
                return allowed
        }</span>

        <span class="cov8" title="1">allowedMap := make(map[string]bool, len(allowed))
        for _, col := range allowed </span><span class="cov8" title="1">{
                allowedMap[col] = true
        }</span>

        <span class="cov8" title="1">var filtered []string
        for _, col := range requested </span><span class="cov8" title="1">{
                if allowedMap[col] </span><span class="cov8" title="1">{
                        filtered = append(filtered, col)
                }</span>
        }

        <span class="cov8" title="1">if len(filtered) == 0 </span><span class="cov8" title="1">{
                return allowed
        }</span>
        <span class="cov8" title="1">return filtered</span>
}

func ValidateOrder(order string) string <span class="cov8" title="1">{
        if order != "asc" &amp;&amp; order != "desc" </span><span class="cov8" title="1">{
                return "desc"
        }</span>
        <span class="cov8" title="1">return order</span>
}

func ValidateOrderBy(orderBy string, allowed []string) string <span class="cov8" title="1">{
        allowedMap := make(map[string]bool, len(allowed))
        for _, col := range allowed </span><span class="cov8" title="1">{
                allowedMap[col] = true
        }</span>
        <span class="cov8" title="1">if allowedMap[orderBy] </span><span class="cov8" title="1">{
                return orderBy
        }</span>
        <span class="cov8" title="1">return "id"</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package helper

import (
        "fmt"
        "net/http"
        "strings"
)

type Filter struct {
        Field    string
        Operator string
        Value    string
}

func GetFilters(r *http.Request, allowed []string) []Filter <span class="cov8" title="1">{
        query := r.URL.Query()

        allowedMap := make(map[string]struct{})
        for _, a := range allowed </span><span class="cov8" title="1">{
                allowedMap[a] = struct{}{}
        }</span>

        <span class="cov8" title="1">var filters []Filter
        for _, raw := range query["filter"] </span><span class="cov8" title="1">{
                parts := strings.SplitN(raw, ":", 3)
                if len(parts) != 3 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">field := strings.TrimSpace(parts[0])
                operator := strings.TrimSpace(strings.ToLower(parts[1]))
                value := strings.TrimSpace(parts[2])

                if _, ok := allowedMap[field]; ok </span><span class="cov8" title="1">{
                        filters = append(filters, Filter{
                                Field:    field,
                                Operator: operator,
                                Value:    value,
                        })
                }</span>
        }

        <span class="cov8" title="1">return filters</span>
}

func BuildWhereClause(filters []Filter) (string, []interface{}) <span class="cov8" title="1">{
        var clauses []string
        var args []interface{}

        for _, f := range filters </span><span class="cov8" title="1">{
                switch f.Operator </span>{
                case "eql":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s = ?", f.Field))
                        args = append(args, f.Value)</span>
                case "neq":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s != ?", f.Field))
                        args = append(args, f.Value)</span>
                case "lik":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s LIKE ?", f.Field))
                        args = append(args, "%"+f.Value+"%")</span>
                case "gt":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s &gt; ?", f.Field))
                        args = append(args, f.Value)</span>
                case "lt":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s &lt; ?", f.Field))
                        args = append(args, f.Value)</span>
                case "gte":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s &gt;= ?", f.Field))
                        args = append(args, f.Value)</span>
                case "lte":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s &lt;= ?", f.Field))
                        args = append(args, f.Value)</span>
                case "btw":<span class="cov8" title="1">
                        rangeParts := strings.Split(f.Value, ",")
                        if len(rangeParts) == 2 </span><span class="cov8" title="1">{
                                clauses = append(clauses, fmt.Sprintf("%s BETWEEN ? AND ?", f.Field))
                                args = append(args, rangeParts[0], rangeParts[1])
                        }</span>
                case "nul":<span class="cov8" title="1">
                        if f.Value == "true" </span><span class="cov8" title="1">{
                                clauses = append(clauses, fmt.Sprintf("%s IS NULL", f.Field))
                        }</span> else<span class="cov8" title="1"> {
                                clauses = append(clauses, fmt.Sprintf("%s IS NOT NULL", f.Field))
                        }</span>
                case "nnu":<span class="cov8" title="1">
                        clauses = append(clauses, fmt.Sprintf("%s IS NOT NULL", f.Field))</span>
                case "in":<span class="cov8" title="1">
                        inParts := strings.Split(f.Value, ",")
                        if len(inParts) &gt; 0 </span><span class="cov8" title="1">{
                                placeholders := strings.Repeat("?,", len(inParts))
                                placeholders = strings.TrimRight(placeholders, ",")
                                clauses = append(clauses, fmt.Sprintf("%s IN (%s)", f.Field, placeholders))
                                for _, val := range inParts </span><span class="cov8" title="1">{
                                        args = append(args, strings.TrimSpace(val))
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(clauses) == 0 </span><span class="cov8" title="1">{
                return "", args
        }</span>

        <span class="cov8" title="1">return "WHERE " + strings.Join(clauses, " AND "), args</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helper

import (
        "net/http"
        "strings"
)

func GetOrderParams(r *http.Request, defaultColumn string) (orderBy string, orderDir string) <span class="cov8" title="1">{
        query := r.URL.Query()

        orderBy = query.Get("order_by")
        if orderBy == "" </span><span class="cov8" title="1">{
                orderBy = defaultColumn
        }</span>

        <span class="cov8" title="1">orderDir = strings.ToLower(query.Get("order"))
        if orderDir != "asc" &amp;&amp; orderDir != "desc" </span><span class="cov8" title="1">{
                orderDir = "desc"
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package helper

import (
        "net/http"
        "strconv"
)

func GetPaginationParams(r *http.Request) (limit int, offset int) <span class="cov8" title="1">{
        const fixedLimit = 5
        page := 1

        query := r.URL.Query()
        if p := query.Get("page"); p != "" </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(p); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov8" title="1">{
                        page = parsed
                }</span>
        }

        <span class="cov8" title="1">limit = fixedLimit
        offset = (page - 1) * fixedLimit
        return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package helper

import (
        "encoding/json"
        "errors"
        "net/http"
        "strings"
)

func JSONResponse(w http.ResponseWriter, status int, payload any) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        _ = json.NewEncoder(w).Encode(payload)
}</span>

func ExtractID(path, prefix string) (string, error) <span class="cov8" title="1">{
        id := strings.TrimPrefix(path, prefix)
        if id == "" </span><span class="cov8" title="1">{
                return "", errors.New("Missing ID")
        }</span>
        <span class="cov8" title="1">return id, nil</span>
}

func FilterList[T any](list []T, fields []string) []map[string]interface{} <span class="cov8" title="1">{
        filtered := make([]map[string]interface{}, 0, len(list))
        for _, item := range list </span><span class="cov8" title="1">{
                filtered = append(filtered, FilterJSON(item, fields))
        }</span>
        <span class="cov8" title="1">return filtered</span>
}

func SanitizeModel(m any) <span class="cov8" title="1">{
        if s, ok := m.(interface{ Sanitize() }); ok </span><span class="cov8" title="1">{
                s.Sanitize()
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package helper

import (
        "database/sql"
        "fmt"
        "strings"
)

func GenericScanToMap(scanner interface {
        Columns() ([]string, error)
        Scan(...any) error
}, schema map[string]string) (map[string]any, error) <span class="cov8" title="1">{
        cols, err := scanner.Columns()
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov8" title="1">scanMap := make(map[string]any)
        scanArgs := make([]any, len(cols))

        for i, col := range cols </span><span class="cov8" title="1">{
                typ, ok := schema[col]
                if !ok </span><span class="cov8" title="1">{
                        var discard any
                        scanArgs[i] = &amp;discard
                        continue</span>
                }

                <span class="cov8" title="1">switch strings.ToLower(typ) </span>{
                case "string":<span class="cov8" title="1">
                        ptr := new(sql.NullString)
                        scanMap[col] = ptr
                        scanArgs[i] = ptr</span>
                case "int":<span class="cov8" title="1">
                        ptr := new(sql.NullInt64)
                        scanMap[col] = ptr
                        scanArgs[i] = ptr</span>
                case "*time.time":<span class="cov8" title="1">
                        ptr := new(sql.NullTime)
                        scanMap[col] = ptr
                        scanArgs[i] = ptr</span>
                default:<span class="cov8" title="1">
                        var discard any
                        scanArgs[i] = &amp;discard</span>
                }
        }

        <span class="cov8" title="1">if err := scanner.Scan(scanArgs...); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scan failed: %w", err)
        }</span>

        <span class="cov8" title="1">result := make(map[string]any)
        for key, ptr := range scanMap </span><span class="cov8" title="1">{
                switch v := ptr.(type) </span>{
                case *sql.NullString:<span class="cov8" title="1">
                        if v.Valid </span><span class="cov8" title="1">{
                                result[key] = v.String
                        }</span> else<span class="cov8" title="1"> {
                                result[key] = ""
                        }</span>
                case *sql.NullInt64:<span class="cov8" title="1">
                        if v.Valid </span><span class="cov8" title="1">{
                                result[key] = int(v.Int64)
                        }</span> else<span class="cov8" title="1"> {
                                result[key] = 0
                        }</span>
                case *sql.NullTime:<span class="cov8" title="1">
                        if v.Valid </span><span class="cov8" title="1">{
                                result[key] = v.Time.Format("2006-01-02 15:04:05")
                        }</span> else<span class="cov8" title="1"> {
                                result[key] = nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return result, nil</span>
}

func MapKeys(m map[string]string) []string <span class="cov8" title="1">{
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package helper

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/go-playground/validator/v10"
)

var validate *validator.Validate = validator.New()

// InjectValidator allows overriding the default validator (used in tests or custom setups)
func InjectValidator(v *validator.Validate) <span class="cov8" title="1">{
        validate = v
}</span>

func ValidatePayload(w http.ResponseWriter, model interface{}) error <span class="cov8" title="1">{
        err := validate.Struct(model)
        if err != nil </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusUnprocessableEntity)

                var errorMessages []string
                if validationErrors, ok := err.(validator.ValidationErrors); ok </span><span class="cov8" title="1">{
                        for _, e := range validationErrors </span><span class="cov8" title="1">{
                                errorMessages = append(errorMessages, fmt.Sprintf(
                                        "Field '%s' failed on the '%s' tag (value: '%v')",
                                        e.Field(), e.Tag(), e.Value(),
                                ))
                        }</span>
                } else<span class="cov8" title="1"> {
                        errorMessages = append(errorMessages, err.Error())
                }</span>

                <span class="cov8" title="1">json.NewEncoder(w).Encode(map[string]any{
                        "errors": errorMessages,
                })</span>
        }
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "net/http"
        "os"
)

var JwtMiddlewareFunc = JwtMiddleware

func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                noAuthMode := os.Getenv("APP_NO_AUTH")
                if noAuthMode == "" </span><span class="cov8" title="1">{
                        noAuthMode = "false"
                }</span>

                <span class="cov8" title="1">exemptPaths := map[string]struct{}{
                        "/health":        {},
                        "/panic":         {},
                        "/auth/generate": {},
                }

                if _, ok := exemptPaths[r.URL.Path]; ok || noAuthMode == "true" </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">JwtMiddlewareFunc(next).ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "net/http"

        "github.com/not-empty/grit/app/helper"
)

func ClosedChain(handler http.Handler) http.Handler <span class="cov8" title="1">{
        return helper.Chain(
                handler,
                LogMiddleware,
                RecoverMiddleware,
                IdMiddleware,
                AuthMiddleware,
                ResponseMiddleware,
                CorsMiddleware,
                SanitizeMiddleware,
        )
}</span>

func AuthChain(handler http.Handler) http.Handler <span class="cov8" title="1">{
        return helper.Chain(
                handler,
                LogMiddleware,
                RecoverMiddleware,
                IdMiddleware,
                CorsMiddleware,
        )
}</span>

func OpenChain(handler http.Handler) http.Handler <span class="cov8" title="1">{
        return helper.Chain(
                handler,
                LogMiddleware,
                RecoverMiddleware,
                IdMiddleware,
                ResponseMiddleware,
                CorsMiddleware,
                SanitizeMiddleware,
        )
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "encoding/json"
        "net/http"
)

func CorsMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                accessMethods := "POST, GET, OPTIONS, PUT, DELETE, PATCH"
                accessHeaders := "Content-Type, Accept, Accept-Language, Authorization, X-Requested-With, Context, Suffix"

                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", accessMethods)
                w.Header().Set("Access-Control-Allow-Headers", accessHeaders)
                w.Header().Set("Access-Control-Allow-Credentials", "true")
                w.Header().Set("Access-Control-Max-Age", "86400")

                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("Referrer-Policy", "no-referrer")
                w.Header().Set("Strict-Transport-Security", "max-age=63072000; includeSubDomains")
                w.Header().Set("Content-Security-Policy", "default-src 'none'")

                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusOK)
                        json.NewEncoder(w).Encode(map[string]string{
                                "method": "OPTIONS",
                        })
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "context"
        "net/http"

        "github.com/not-empty/grit/app/util/ulid"

        appctx "github.com/not-empty/grit/app/context"
)

func IdMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        var u ulid.Ulid

        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                reqID := u.Generate(0)
                ctx := r.Context()
                ctx = context.WithValue(ctx, appctx.RequestIDKey, reqID)
                next.ServeHTTP(w, r.WithContext(ctx))
        }</span>)
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "context"
        "encoding/json"
        "net/http"
        "os"
        "strconv"
        "strings"
        "time"

        appctx "github.com/not-empty/grit/app/context"
        "github.com/not-empty/grit/app/util/jwt_manager"
)

var NewJwtManager = func(secret, context string, expire, renew int64) jwt_manager.Manager <span class="cov8" title="1">{
        return jwt_manager.NewJwtManager(secret, context, expire, renew)
}</span>

func JwtMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                tokenHeader := r.Header.Get("Authorization")
                contextHeader := r.Header.Get("Context")
                if tokenHeader == "" || contextHeader == "" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Missing authorization or context"})
                        return
                }</span>

                <span class="cov8" title="1">token := strings.TrimPrefix(tokenHeader, "Bearer ")

                jwtSecret := os.Getenv("JWT_APP_SECRET")
                if jwtSecret == "" </span><span class="cov8" title="1">{
                        jwtSecret = "default_secret"
                }</span>

                <span class="cov8" title="1">expireStr := os.Getenv("JWT_EXPIRE")
                renewStr := os.Getenv("JWT_RENEW")

                expire, err := strconv.ParseInt(expireStr, 10, 64)
                if err != nil || expireStr == "" </span><span class="cov8" title="1">{
                        expire = 900
                }</span>

                <span class="cov8" title="1">renew, err := strconv.ParseInt(renewStr, 10, 64)
                if err != nil || renewStr == "" </span><span class="cov8" title="1">{
                        renew = 300
                }</span>

                <span class="cov8" title="1">jwtMgr := NewJwtManager(jwtSecret, contextHeader, expire, renew)

                if valid, err := jwtMgr.IsValid(token); err != nil || !valid </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Invalid or expired token"})
                        return
                }</span>

                <span class="cov8" title="1">if onTime, err := jwtMgr.IsOnTime(token); err != nil || !onTime </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Token expired or not yet valid"})
                        return
                }</span>

                <span class="cov8" title="1">payload, err := jwtMgr.DecodePayload(token)
                if err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Failed to decode token payload"})
                        return
                }</span>

                <span class="cov8" title="1">aud, _ := payload["aud"].(string)
                sub, _ := payload["sub"].(string)
                if aud != contextHeader || sub != "api" </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Invalid token context or subject"})
                        return
                }</span>

                <span class="cov8" title="1">expFloat, ok := payload["exp"].(float64)
                if !ok </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusUnauthorized)
                        json.NewEncoder(w).Encode(map[string]string{"error": "Invalid expiration format"})
                        return
                }</span>

                <span class="cov8" title="1">expires := time.Unix(int64(expFloat), 0).Format("2006-01-02 15:04:05")

                if needsRefresh, err := jwtMgr.TokenNeedsRefresh(token); err == nil &amp;&amp; needsRefresh </span><span class="cov8" title="1">{
                        token = jwtMgr.Generate(aud, sub, map[string]interface{}{})
                        expires = time.Now().Add(time.Duration(expire) * time.Second).Format("2006-01-02 15:04:05")
                }</span>

                <span class="cov8" title="1">ctx := r.Context()
                ctx = context.WithValue(ctx, appctx.JwtContextKey, appctx.JwtTokenInfo{
                        Token:   token,
                        Expires: expires,
                })
                ctx = context.WithValue(ctx, appctx.AppVersionKey, "v1.0.0")

                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "log"
        "net"
        "net/http"
        "net/url"
        "os"
        "time"

        appctx "github.com/not-empty/grit/app/context"
)

type statusRecorder struct {
        http.ResponseWriter
        StatusCode int
}

func (rec *statusRecorder) WriteHeader(code int) <span class="cov8" title="1">{
        rec.StatusCode = code
        rec.ResponseWriter.WriteHeader(code)
}</span>

func LogMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if os.Getenv("APP_LOG") != "true" </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov8" title="1">start := time.Now()
                rec := &amp;statusRecorder{ResponseWriter: w, StatusCode: 200}
                next.ServeHTTP(rec, r)

                ip := r.RemoteAddr
                if host, _, err := net.SplitHostPort(ip); err == nil </span><span class="cov8" title="1">{
                        ip = host
                }</span>

                <span class="cov8" title="1">queryDecoded, err := url.QueryUnescape(r.URL.RawQuery)
                if err != nil </span><span class="cov8" title="1">{
                        queryDecoded = r.URL.RawQuery
                }</span>

                <span class="cov8" title="1">fullPath := r.URL.Path
                if queryDecoded != "" </span><span class="cov8" title="1">{
                        fullPath += "?" + queryDecoded
                }</span>

                <span class="cov8" title="1">reqID, _ := r.Context().Value(appctx.RequestIDKey).(string)

                log.Printf("%s [%s] %s %s %d %s", reqID, r.Method, ip, fullPath, rec.StatusCode, time.Since(start))</span>
        })
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "runtime/debug"
)

func RecoverMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if rec := recover(); rec != nil </span><span class="cov8" title="1">{
                                appEnv := os.Getenv("APP_ENV")
                                response := map[string]interface{}{
                                        "error": "Internal Server Error",
                                }
                                if appEnv == "local" </span><span class="cov8" title="1">{
                                        response["panic_error"] = fmt.Sprintf("%v", rec)
                                        response["stacktrace"] = string(debug.Stack())
                                }</span>
                                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                                w.WriteHeader(http.StatusInternalServerError)
                                json.NewEncoder(w).Encode(response)</span>
                        }
                }()
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "bytes"
        "fmt"
        "net/http"
        "strings"
        "time"

        appctx "github.com/not-empty/grit/app/context"
)

type responseRecorder struct {
        http.ResponseWriter
        status int
        body   bytes.Buffer
}

func (rr *responseRecorder) Header() http.Header <span class="cov8" title="1">{
        return rr.ResponseWriter.Header()
}</span>

func (rr *responseRecorder) WriteHeader(status int) <span class="cov8" title="1">{
        rr.status = status
}</span>

func (rr *responseRecorder) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if rr.status == 0 </span><span class="cov8" title="1">{
                rr.status = http.StatusOK
        }</span>
        <span class="cov8" title="1">return rr.body.Write(b)</span>
}

func ResponseMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                rr := &amp;responseRecorder{ResponseWriter: w}
                next.ServeHTTP(rr, r)

                elapsed := time.Since(start).Seconds()

                jwtInfo := appctx.JwtTokenInfo{}
                if info := r.Context().Value(appctx.JwtContextKey); info != nil </span><span class="cov8" title="1">{
                        if tokenInfo, ok := info.(appctx.JwtTokenInfo); ok </span><span class="cov8" title="1">{
                                jwtInfo = tokenInfo
                        }</span>
                }

                <span class="cov8" title="1">requestID := ""
                if rid := r.Context().Value(appctx.RequestIDKey); rid != nil </span><span class="cov8" title="1">{
                        if str, ok := rid.(string); ok </span><span class="cov8" title="1">{
                                requestID = str
                        }</span>
                }

                <span class="cov8" title="1">w.Header().Set("X-Token", jwtInfo.Token)
                w.Header().Set("X-Expires", jwtInfo.Expires)
                w.Header().Set("X-Request-ID", requestID)
                w.Header().Set("X-Profile", formatProfile(elapsed))

                if rr.status == http.StatusNoContent </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(rr.status)
                w.Write(rr.body.Bytes())</span>
        })
}

func formatProfile(sec float64) string <span class="cov8" title="1">{
        return strings.TrimRight(strings.TrimRight(fmt.Sprintf("%.9f", sec), "0"), ".")
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "net/http"
        "strings"
)

func sanitizeInputValues(values []string) []string <span class="cov8" title="1">{
        cleaned := make([]string, len(values))
        for i, v := range values </span><span class="cov8" title="1">{
                clean := strings.ReplaceAll(v, `"`, "")
                clean = strings.ReplaceAll(clean, `'`, "")
                cleaned[i] = clean
        }</span>
        <span class="cov8" title="1">return cleaned</span>
}

func SanitizeMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                query := r.URL.Query()
                for key, values := range query </span><span class="cov8" title="1">{
                        query[key] = sanitizeInputValues(values)
                }</span>
                <span class="cov8" title="1">r.URL.RawQuery = query.Encode()

                for key, values := range r.Header </span><span class="cov8" title="1">{
                        r.Header[key] = sanitizeInputValues(values)
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package jwt_manager

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "strings"
        "time"
)

// Interface for mocking/testing
type Manager interface {
        Generate(audience, subject string, custom map[string]interface{}) string
        IsValid(token string) (bool, error)
        IsOnTime(token string) (bool, error)
        TokenNeedsRefresh(token string) (bool, error)
        DecodePayload(token string) (map[string]interface{}, error)
}

// Ensure JwtManager implements the interface
var _ Manager = (*JwtManager)(nil)

// Struct implementation
type JwtManager struct {
        AppSecret string
        Context   string
        Expire    int64 // in seconds
        Renew     int64 // in seconds
        algorithm string
        tokenType string
}

// Factory returns the interface
func NewJwtManager(secret, context string, expire, renew int64) Manager <span class="cov8" title="1">{
        return &amp;JwtManager{
                AppSecret: secret,
                Context:   context,
                Expire:    expire,
                Renew:     renew,
                algorithm: "HS256",
                tokenType: "JWT",
        }
}</span>

// JWT Generation

func (j *JwtManager) getHeader() string <span class="cov0" title="0">{
        header := map[string]string{
                "alg": j.algorithm,
                "typ": j.tokenType,
        }
        data, _ := json.Marshal(header)
        return base64UrlEncode(data)
}</span>

func (j *JwtManager) getPayload(audience, subject string, custom map[string]interface{}) string <span class="cov0" title="0">{
        now := time.Now().Unix()
        payload := map[string]interface{}{
                "aud": audience,
                "exp": now + j.Expire,
                "iat": now,
                "iss": j.Context,
                "sub": subject,
        }
        for k, v := range custom </span><span class="cov0" title="0">{
                payload[k] = v
        }</span>
        <span class="cov0" title="0">data, _ := json.Marshal(payload)
        return base64UrlEncode(data)</span>
}

func (j *JwtManager) getSignature(header, payload string) string <span class="cov0" title="0">{
        h := hmac.New(sha256.New, []byte(j.AppSecret))
        h.Write([]byte(header + "." + payload))
        return base64UrlEncode(h.Sum(nil))
}</span>

func (j *JwtManager) Generate(audience, subject string, custom map[string]interface{}) string <span class="cov0" title="0">{
        header := j.getHeader()
        payload := j.getPayload(audience, subject, custom)
        signature := j.getSignature(header, payload)
        return header + "." + payload + "." + signature
}</span>

// JWT Validation

func (j *JwtManager) IsValid(token string) (bool, error) <span class="cov0" title="0">{
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return false, errors.New("invalid JWT format")
        }</span>
        <span class="cov0" title="0">expectedSig := j.getSignature(parts[0], parts[1])
        if parts[2] != expectedSig &amp;&amp; parts[2] != expectedSig+"=" </span><span class="cov0" title="0">{
                return false, errors.New("invalid JWT signature")
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (j *JwtManager) IsOnTime(token string) (bool, error) <span class="cov0" title="0">{
        payload, err := j.DecodePayload(token)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">exp, ok := payload["exp"].(float64)
        if !ok || int64(exp) &lt; time.Now().Unix() </span><span class="cov0" title="0">{
                return false, errors.New("JWT expired")
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (j *JwtManager) TokenNeedsRefresh(token string) (bool, error) <span class="cov0" title="0">{
        payload, err := j.DecodePayload(token)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">iat, ok := payload["iat"].(float64)
        if !ok </span><span class="cov0" title="0">{
                return false, errors.New("invalid JWT payload: missing iat")
        }</span>
        <span class="cov0" title="0">if time.Now().Unix() &gt; int64(iat)+j.Renew </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">return false, nil</span>
}

func (j *JwtManager) DecodePayload(token string) (map[string]interface{}, error) <span class="cov0" title="0">{
        parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token format")
        }</span>
        <span class="cov0" title="0">payloadJson, err := base64UrlDecode(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var payload map[string]interface{}
        err = json.Unmarshal([]byte(payloadJson), &amp;payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return payload, nil</span>
}

// Helpers

func base64UrlEncode(data []byte) string <span class="cov0" title="0">{
        return base64.URLEncoding.WithPadding(base64.NoPadding).EncodeToString(data)
}</span>

func base64UrlDecode(data string) (string, error) <span class="cov0" title="0">{
        decoded, err := base64.URLEncoding.WithPadding(base64.NoPadding).DecodeString(data)
        return string(decoded), err
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package ulid

import (
        "errors"
        "math"
        "strings"
        "time"
)

const (
        CHARS         = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        BASE          = 32
        TIME_MAX      = 281474976710655
        TIME_LENGTH   = 10
        RANDOM_LENGTH = 16
)

type Ulid struct {
        LastGenTime   int64
        LastRandChars []int
}

func (u *Ulid) IsValidFormat(ulidStr string) bool <span class="cov0" title="0">{
        return len(ulidStr) == TIME_LENGTH+RANDOM_LENGTH
}</span>

func (u *Ulid) GetTimeFromUlid(ulidStr string) (int64, error) <span class="cov0" title="0">{
        if !u.IsValidFormat(ulidStr) </span><span class="cov0" title="0">{
                return 0, errors.New("invalid ULID format")
        }</span>
        <span class="cov0" title="0">timePart := ulidStr[:TIME_LENGTH]
        return u.DecodeTime(timePart)</span>
}

func (u *Ulid) GetDateFromUlid(ulidStr string) (string, error) <span class="cov0" title="0">{
        t, err := u.GetTimeFromUlid(ulidStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return time.Unix(t, 0).Format("2006-01-02 15:04:05"), nil</span>
}

func (u *Ulid) GetRandomnessFromString(ulidStr string) (string, error) <span class="cov0" title="0">{
        if !u.IsValidFormat(ulidStr) </span><span class="cov0" title="0">{
                return "", errors.New("invalid ULID format")
        }</span>
        <span class="cov0" title="0">return ulidStr[TIME_LENGTH:], nil</span>
}

func (u *Ulid) IsDuplicatedTime(t int64) bool <span class="cov8" title="1">{
        return t == u.LastGenTime
}</span>

func (u *Ulid) HasIncrementLastRandChars(duplicateTime bool) bool <span class="cov8" title="1">{
        if !duplicateTime </span><span class="cov8" title="1">{
                u.LastRandChars = make([]int, RANDOM_LENGTH)
                for i := 0; i &lt; RANDOM_LENGTH; i++ </span><span class="cov8" title="1">{
                        u.LastRandChars[i] = randomInt(0, BASE-1)
                }</span>
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov0" title="0">for i := RANDOM_LENGTH - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if u.LastRandChars[i] == BASE-1 </span><span class="cov0" title="0">{
                        u.LastRandChars[i] = 0
                }</span> else<span class="cov0" title="0"> {
                        u.LastRandChars[i]++
                        break</span>
                }
        }
        <span class="cov0" title="0">return true</span>
}

func (u *Ulid) Generate(t int64) string <span class="cov8" title="1">{
        if t == 0 </span><span class="cov8" title="1">{
                t = int64(time.Now().UnixNano() / 1e6)
        }</span>

        <span class="cov8" title="1">duplicateTime := u.IsDuplicatedTime(t)
        u.LastGenTime = t

        timeChars := ""
        temp := t
        for i := 0; i &lt; TIME_LENGTH; i++ </span><span class="cov8" title="1">{
                mod := temp % BASE
                timeChars = string(CHARS[mod]) + timeChars
                temp = temp / BASE
        }</span>

        <span class="cov8" title="1">u.HasIncrementLastRandChars(duplicateTime)
        randChars := ""
        for i := 0; i &lt; RANDOM_LENGTH; i++ </span><span class="cov8" title="1">{
                randChars += string(CHARS[u.LastRandChars[i]])
        }</span>

        <span class="cov8" title="1">return timeChars + randChars</span>
}

func (u *Ulid) DecodeTime(timePart string) (int64, error) <span class="cov0" title="0">{
        if len(timePart) != TIME_LENGTH </span><span class="cov0" title="0">{
                return 0, errors.New("invalid time part length")
        }</span>
        <span class="cov0" title="0">reversed := reverseString(timePart)
        var carry int64 = 0
        for i, char := range reversed </span><span class="cov0" title="0">{
                index := strings.IndexRune(CHARS, char)
                if index == -1 </span><span class="cov0" title="0">{
                        return 0, errors.New("invalid ULID character: " + string(char))
                }</span>
                <span class="cov0" title="0">carry += int64(index) * int64(math.Pow(float64(BASE), float64(i)))</span>
        }
        <span class="cov0" title="0">if carry &gt; TIME_MAX </span><span class="cov0" title="0">{
                return 0, errors.New("timestamp too large")
        }</span>
        <span class="cov0" title="0">return carry, nil</span>
}

func reverseString(s string) string <span class="cov0" title="0">{
        runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov0" title="0">return string(runes)</span>
}

func randomInt(min, max int) int <span class="cov8" title="1">{
        return min + int(time.Now().UnixNano()%int64(max-min+1))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

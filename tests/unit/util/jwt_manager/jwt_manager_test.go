package jwt_manager

import (
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/not-empty/grit/app/util/jwt_manager"
	"github.com/stretchr/testify/require"
)

func TestJwtManager_Generate_ValidFormat(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("test-audience", "test-subject", map[string]interface{}{"custom": "value"})

	parts := strings.Split(token, ".")
	require.Len(t, parts, 3, "A valid token must have 3 parts separated by '.'")
}

func TestJwtManager_IsValid_ValidToken(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("test-audience", "test-subject", nil)

	valid, err := jm.IsValid(token)
	require.NoError(t, err)
	require.True(t, valid, "A token generated by Generate should be valid")
}

func TestJwtManager_IsValid_InvalidFormat(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := "invalid.token"
	valid, err := jm.IsValid(token)
	require.Error(t, err)
	require.False(t, valid)
	require.Contains(t, err.Error(), "invalid JWT format")
}

func TestJwtManager_IsValid_InvalidSignature(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("test-audience", "test-subject", nil)
	parts := strings.Split(token, ".")
	parts[2] = "tamperedSignature"
	tampered := strings.Join(parts, ".")
	valid, err := jm.IsValid(tampered)
	require.Error(t, err)
	require.False(t, valid)
	require.Contains(t, err.Error(), "invalid JWT signature")
}

func TestJwtManager_DecodePayload_Valid(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("audience", "subject", map[string]interface{}{"custom": "value"})

	payload, err := jm.DecodePayload(token)
	require.NoError(t, err)
	require.Equal(t, "audience", payload["aud"])
	require.Equal(t, "TestContext", payload["iss"])
	require.Equal(t, "subject", payload["sub"])
	_, ok := payload["exp"].(float64)
	require.True(t, ok, "exp claim should be a number")
	_, ok = payload["iat"].(float64)
	require.True(t, ok, "iat claim should be a number")
}

func TestJwtManager_IsOnTime_Valid(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("aud", "sub", nil)

	onTime, err := jm.IsOnTime(token)
	require.NoError(t, err)
	require.True(t, onTime, "Newly generated token should be on time")
}

func TestJwtManager_IsOnTime_Expired(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", -1, 1800)
	token := jm.Generate("aud", "sub", nil)

	onTime, err := jm.IsOnTime(token)
	require.Error(t, err)
	require.False(t, onTime)
	require.Contains(t, err.Error(), "JWT expired")
}

func TestJwtManager_TokenNeedsRefresh(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := jm.Generate("aud", "sub", nil)
	parts := strings.Split(token, ".")
	payloadJson, err := jwt_manager.Base64UrlDecode(parts[1])
	require.NoError(t, err)

	var payload map[string]interface{}
	err = json.Unmarshal([]byte(payloadJson), &payload)
	require.NoError(t, err)
	oldIat := float64(time.Now().Unix() - 2000)
	payload["iat"] = oldIat
	newPayloadBytes, err := json.Marshal(payload)
	require.NoError(t, err)
	newPayload := jwt_manager.Base64UrlEncode(newPayloadBytes)
	newToken := parts[0] + "." + newPayload + "." + parts[2]

	needsRefresh, err := jm.TokenNeedsRefresh(newToken)
	require.NoError(t, err)
	require.True(t, needsRefresh, "Token should need refresh when iat is too old")
}

func TestJwtManager_DecodePayload_InvalidFormat(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := "invalid.token"
	payload, err := jm.DecodePayload(token)
	require.Error(t, err)
	require.Nil(t, payload)
	require.Contains(t, err.Error(), "invalid token format")
}

func TestJwtManager_DecodePayload_InvalidJSON(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	header := jm.(*jwt_manager.JwtManager).GetHeader()
	invalidPayload := "notjson"
	signature := jm.(*jwt_manager.JwtManager).GetSignature(header, invalidPayload)
	token := header + "." + invalidPayload + "." + signature

	payload, err := jm.DecodePayload(token)
	require.Error(t, err)
	require.Nil(t, payload)
}

func TestJwtManager_IsOnTime_InvalidPayload(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := "header.invalidPayload.signature"
	onTime, err := jm.IsOnTime(token)
	require.False(t, onTime, "IsOnTime should return false when payload is invalid")
	require.Error(t, err, "Expected an error due to invalid payload in token")
	require.Contains(t, err.Error(), "Illegal base64", "Error message should indicate base64 decoding failure")
}

func encode(data interface{}) string {
	bytes, _ := json.Marshal(data)
	return jwt_manager.Base64UrlEncode(bytes)
}

func TestTokenNeedsRefresh_DecodeError(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	token := "header.payload"
	needsRefresh, err := jm.TokenNeedsRefresh(token)
	require.False(t, needsRefresh, "Token should not need refresh on decode error")
	require.Error(t, err)
	require.Equal(t, "Illegal base64", err.Error(), "Expected normalized error message for decode failure")
}

func TestTokenNeedsRefresh_MissingIat(t *testing.T) {
	header := encode(map[string]string{"alg": "HS256", "typ": "JWT"})
	payload := encode(map[string]interface{}{
		"exp": time.Now().Unix() + 3600,
	})
	signature := "dummySignature"
	token := strings.Join([]string{header, payload, signature}, ".")

	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	needsRefresh, err := jm.TokenNeedsRefresh(token)
	require.False(t, needsRefresh, "Token without iat should not be considered valid")
	require.Error(t, err)
	require.Equal(t, "invalid JWT payload: missing iat", err.Error(), "Expected error about missing iat")
}

func TestTokenNeedsRefresh_NoRefreshNeeded(t *testing.T) {
	now := time.Now().Unix()
	payloadData := map[string]interface{}{
		"iat": now,
		"exp": now + 3600,
		"aud": "test",
		"iss": "TestContext",
		"sub": "subject",
	}
	header := encode(map[string]string{"alg": "HS256", "typ": "JWT"})
	payload := encode(payloadData)
	token := strings.Join([]string{header, payload, "dummySig"}, ".")

	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)
	needsRefresh, err := jm.TokenNeedsRefresh(token)
	require.NoError(t, err)
	require.False(t, needsRefresh, "A freshly issued token should not need refresh")
}

func TestJwtManager_DecodePayload_IllegalBase64(t *testing.T) {
	jm := jwt_manager.NewJwtManager("mysecret", "TestContext", 3600, 1800)

	header := jm.(*jwt_manager.JwtManager).GetHeader()
	invalidPayload := "!!!"
	signature := "dummySignature"

	token := header + "." + invalidPayload + "." + signature

	payload, err := jm.DecodePayload(token)
	require.Error(t, err, "Expected an error from DecodePayload for invalid base64 payload")
	require.Nil(t, payload, "Payload should be nil on error")
	require.Equal(t, "Illegal base64", err.Error(), "Error message should be normalized to 'Illegal base64'")
}
